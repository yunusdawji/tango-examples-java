//
//  EncryptionHelper.m
//  Hyphen
//
//  Created by Yunus Dawji on 2014-07-14.
//  Copyright (c) 2014 Apple. All rights reserved.
//

#import "EncryptionHelper.h"

enum {
	CSSM_ALGID_NONE =					0x00000000L,
	CSSM_ALGID_VENDOR_DEFINED =			CSSM_ALGID_NONE + 0x80000000L,
	CSSM_ALGID_AES
};


Byte puliccertificate[] = {0x30,0x82,0x02,0xd7 ,0x30,0x82,0x01,0xbf ,0xa0,0x03,0x02,0x01,0x02,0x02,0x04,0x3a ,0xa4,0x97,0xff,0x30 ,0x0d,0x06,0x09,0x2a ,0x86,0x48,0x86,0xf7 ,0x0d,0x01,0x01,0x0b ,0x05,0x00,0x30,0x1c ,0x31,0x1a,0x30,0x18 ,0x06,0x03,0x55,0x04 ,0x03,0x13,0x11,0x70 ,0x6c,0x61,0x73,0x74 ,0x69,0x63,0x6d,0x6f ,0x62,0x69,0x6c,0x65 ,0x2e,0x63,0x6f,0x6d ,0x30,0x1e,0x17,0x0d ,0x31,0x34,0x30,0x37 ,0x31,0x30,0x31,0x35 ,0x35,0x34,0x31,0x31 ,0x5a,0x17,0x0d,0x32 ,0x39,0x30,0x37,0x30 ,0x36,0x31,0x35,0x35 ,0x34,0x31,0x31,0x5a ,0x30,0x1c,0x31,0x1a ,0x30,0x18,0x06,0x03 ,0x55,0x04,0x03,0x13 ,0x11,0x70,0x6c,0x61 ,0x73,0x74,0x69,0x63 ,0x6d,0x6f,0x62,0x69 ,0x6c,0x65,0x2e,0x63 ,0x6f,0x6d,0x30,0x82 ,0x01,0x22,0x30,0x0d ,0x06,0x09,0x2a,0x86 ,0x48,0x86,0xf7,0x0d ,0x01,0x01,0x01,0x05 ,0x00,0x03,0x82,0x01 ,0x0f,0x00,0x30,0x82 ,0x01,0x0a,0x02,0x82 ,0x01,0x01,0x00,0x9a ,0xe6,0x81,0xa6,0x48 ,0xf8,0x35,0x4b,0x4c ,0x18,0x81,0x9b,0x94 ,0x67,0x2a,0x4c,0xb0 ,0x85,0x4c,0x8f,0x7a ,0xfe,0x96,0xd0,0x26 ,0x3a,0x61,0xd5,0x1e ,0x18,0xd5,0x1d,0x1b ,0xc5,0x3d,0xe3,0x95 ,0xf5,0x79,0xc4,0x11 ,0x53,0xef,0x90,0x22 ,0xe5,0x57,0x6b,0x00 ,0x2b,0xf1,0x8c,0x6e ,0x74,0xd1,0x12,0x91 ,0x4e,0xa2,0xd8,0x1b ,0x63,0xf6,0x7a,0xc8 ,0xd5,0x52,0xc3,0xb1 ,0x29,0x55,0xb8,0xf2 ,0x10,0x2e,0xc8,0x80 ,0x44,0x2a,0xe3,0x20 ,0x8d,0xcf,0x24,0x8c ,0x3d,0xea,0xe8,0x11 ,0xa4,0xd4,0x5b,0x52 ,0xde,0xc4,0xb6,0x57 ,0xe8,0x07,0xb8,0xfb ,0x71,0xfd,0xf6,0x9c ,0xe4,0x4a,0xae,0xe8 ,0x37,0x62,0xf6,0x02 ,0xcb,0x08,0x88,0x26 ,0x7d,0xb7,0x62,0x3d ,0x45,0x5e,0x6d,0xb4 ,0xbe,0xfb,0x27,0xda ,0x27,0x7b,0xd9,0x5c ,0x87,0x1e,0x4b,0x1d ,0x3c,0x47,0x53,0xb8 ,0x0f,0x98,0x6c,0x8c ,0xca,0x7b,0x7d,0xca ,0xbd,0xad,0x52,0x25 ,0xa1,0x46,0x30,0xb9 ,0xb4,0xbe,0xdf,0x6a ,0xc9,0xdf,0x94,0x47 ,0x04,0xa7,0x62,0xa0 ,0x31,0x45,0x85,0x9a ,0x09,0xc4,0x4d,0xa4 ,0x5e,0x0b,0xf0,0xd7 ,0xbe,0xcd,0x6a,0xe4 ,0xb5,0x0a,0x9c,0x96 ,0x87,0x99,0x01,0x59 ,0xc9,0x10,0x96,0x5a ,0xec,0x83,0xa1,0xe5 ,0x02,0xba,0x49,0x06 ,0x97,0xc0,0x4f,0xf1 ,0x3a,0xe8,0x8f,0x69 ,0xef,0xc9,0x75,0x1b ,0xb5,0x6c,0x2e,0x09 ,0x6b,0x04,0xe3,0xfb ,0x51,0xa8,0x66,0xec ,0xc4,0xbf,0x66,0xbf ,0xf5,0xf8,0x48,0x41 ,0x88,0x53,0x65,0x1e ,0x32,0xdf,0x38,0x45 ,0xa8,0xe6,0x3f,0xf1,0x06,0x12,0xff,0x3c ,0x5f,0x48,0x75,0x02 ,0x03,0x01,0x00,0x01 ,0xa3,0x21,0x30,0x1f ,0x30,0x1d,0x06,0x03 ,0x55,0x1d,0x0e,0x04 ,0x16,0x04,0x14,0xf0 ,0xa2,0xbc,0xdd,0x91 ,0x7d,0xd2,0xf8,0x39 ,0xfc,0xe1,0x6e,0xa3 ,0x5b,0x7a,0x82,0xf4 ,0x69,0x84,0x93,0x30 ,0x0d,0x06,0x09,0x2a ,0x86,0x48,0x86,0xf7 ,0x0d,0x01,0x01,0x0b ,0x05,0x00,0x03,0x82 ,0x01,0x01,0x00,0x04 ,0x25,0x30,0x51,0x83 ,0x39,0x9c,0xc3,0x2a ,0xe4,0xcb,0xe9,0x77 ,0xe0,0x9c,0x44,0xf9 ,0xa5,0x07,0xd3,0x07 ,0xcb,0xe8,0xd1,0xfa ,0xa4,0xf9,0x65,0xb1 ,0xf4,0x0f,0xe2,0x07 ,0xfe,0x8b,0xdf,0x35 ,0x2a,0xd4,0x6d,0x18 ,0x57,0xad,0x10,0xd2 ,0xa7,0xf6,0x1e,0x75 ,0x71,0xba,0x58,0xae ,0xb8,0xf1,0x01,0xf9 ,0xaf,0x05,0xfe,0x99 ,0xb5,0x73,0x86,0x23 ,0xda,0x0f,0xf9,0xfb ,0xff,0x8b,0x46,0xfd ,0x92,0xc9,0xa0,0x54 ,0x04,0x48,0xa7,0x47 ,0x08,0x85,0x36,0x6d ,0xfc,0x7f,0xd2,0x76 ,0xbc,0x98,0xe2,0x97 ,0x86,0xa6,0x53,0x01 ,0x8b,0x03,0x48,0x7a ,0x28,0xe6,0xc9,0x1a ,0x93,0xf6,0xab,0x52 ,0x27,0x90,0xc3,0xc1 ,0x0e,0xd6,0x02,0x86 ,0x89,0xde,0x12,0x47 ,0x07,0x87,0x53,0x38 ,0x61,0x68,0x29,0xf9 ,0xf2,0xfc,0x21,0x7e ,0xc2,0x94,0x13,0xe9 ,0x02,0xf5,0xac,0xfb ,0x50,0x1f,0x9d,0x28 ,0x8b,0x88,0x19,0xcf ,0xa1,0xa6,0xfc,0x60 ,0x58,0x44,0x1e,0xae ,0x19,0x9f,0x26,0x88 ,0x90,0x24,0x7a,0xae ,0x05,0xe3,0xc4,0xc3 ,0x88,0x8d,0x96,0x41 ,0x8c,0x7b,0x24,0x1a ,0x21,0x44,0x5e,0x67 ,0x08,0x8f,0xf0,0x7f ,0x94,0x43,0xab,0x8d ,0x39,0xf4,0x82,0x34 ,0x8d,0x6d,0xbc,0x4b ,0x22,0x62,0x0f,0x2a ,0x1d,0x09,0x9d,0xd3 ,0x0c,0xf0,0x06,0xea ,0x39,0x0e,0x73,0xed ,0x06,0x1e,0x0b,0x6b ,0xde,0x40,0xcd,0xed ,0x86,0x17,0x7d,0x39 ,0xec,0xbf,0x11,0xc4 ,0xa3,0xda,0x39,0x38 ,0x7e,0x64,0xe0,0x7b ,0xab,0x7a,0x91,0x7c ,0x5d,0x1d,0xe9,0x48 ,0xb1,0x98,0x11,0xe5 ,0xf0,0x70,0x5c,0xa4 ,0x4e,0xbc,0x03};

@implementation EncryptionHelper


@synthesize symmetricTag, symmetricKey;

#if DEBUG
#define LOGGING_FACILITY(X, Y)	\
NSAssert(X, Y);

#define LOGGING_FACILITY1(X, Y, Z)	\
NSAssert1(X, Y, Z);
#else
#define LOGGING_FACILITY(X, Y)	\
if (!(X)) {			\
NSLog(Y);		\
}

#define LOGGING_FACILITY1(X, Y, Z)	\
if (!(X)) {				\
NSLog(Y, Z);		\
}
#endif

static const uint8_t symmetricKeyIdentifier[]	= kSymmetricKeyTag;


-(id) init {
    self = [super init];
    
    symmetricTag = [[NSData alloc] initWithBytes:symmetricKeyIdentifier length:sizeof(symmetricKeyIdentifier)];
    
    return self;
}

- (NSData *) encryptWithRSA:(NSData *)content {
    
    size_t plainLen = [content length];
    
    if (plainLen > maxPlainLen) {
        NSLog(@"content(%ld) is too long, must < %ld", plainLen, maxPlainLen);
        return nil;
    }
    
    void *plain = malloc(plainLen);
    [content getBytes:plain length:plainLen];
    
    size_t cipherLen = 256; // currently RSA key length is set to 256 bytes
    void *cipher = malloc(cipherLen);
    
    OSStatus returnCode = SecKeyEncrypt(publicKey, kSecPaddingPKCS1, plain,
                                        plainLen, cipher, &cipherLen);
    
    
    NSData *result = nil;
    if (returnCode != 0) {
        NSLog(@"SecKeyEncrypt fail. Error Code: %d", (int)returnCode);
    }
    else {
        result = [NSData dataWithBytes:cipher
                                length:cipherLen];
    }
    
    free(plain);
    free(cipher);
    
    return result;
}




- (NSData*) encryptWithAES:(NSData *)content key:(NSData *)key
{
    unsigned char *keyPtr = (unsigned char *)[key bytes];
    size_t numBytesEncrypted = 0;
    
    NSUInteger dataLength = [content length];
    
    size_t bufferSize = dataLength + 2*kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);
    const unsigned char iv[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};;
    
    CCCryptorStatus result = CCCrypt( kCCEncrypt,
                                     kCCAlgorithmAES128,
                                     kCCOptionPKCS7Padding,
                                     keyPtr,
                                     kCCKeySizeAES256,
                                     iv,
                                     [content bytes], [content length],
                                     buffer, bufferSize,
                                     &numBytesEncrypted );
    
    if( result == kCCSuccess )
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
    else {
        NSLog(@"Failed AES");
    }
    return nil;
}
- (void) generateSymmetricKeyCertificate {
    [self generateSymmetricKeyCertificate:[[NSData alloc] initWithBytes:puliccertificate length:731]];
}

- (void) generateSymmetricKeyCertificate: (NSData *) content {
    NSUInteger len = [content length];
    Byte *data = (Byte*)malloc(len);
    memcpy(data, [content bytes], len);
    
    CFDataRef temp = CFDataCreate(NULL, data, 731);
    
    
    // create a certificate from data
    SecCertificateRef tempcertficate =  SecCertificateCreateWithData (NULL ,temp);
    
    // Create SecTrust and get Public Key
    CFArrayRef certs = CFArrayCreate(kCFAllocatorDefault, (const void **) &tempcertficate, 1, NULL);
    
    policy = SecPolicyCreateBasicX509();
    
    SecTrustCreateWithCertificates(certs, policy, &trust);
    
    SecTrustResultType trustResult;
    SecTrustEvaluate(trust, &trustResult);
    
    publicKey = SecTrustCopyPublicKey(trust);
    maxPlainLen = SecKeyGetBlockSize(publicKey) - 12;
    
    
    [self generateSymmetricKey];
    
}

- (NSData *) decryptWithAES:(NSData *)content key:(NSData *)key
{
    unsigned char *keyPtr = (unsigned char *)[key bytes];
    
    size_t numBytesEncrypted = 0;
    
    NSUInteger dataLength = [content length];
    
    size_t bufferSize = dataLength + 2*kCCBlockSizeAES128;
    void *buffer_decrypt = malloc(bufferSize);
    const unsigned char iv[] ={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};;
    
    CCCryptorStatus result = CCCrypt( kCCDecrypt , kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                     keyPtr, kCCKeySizeAES256,
                                     iv,
                                     [content bytes], [content length],
                                     buffer_decrypt, bufferSize,
                                     &numBytesEncrypted );
    
    if( result == kCCSuccess )
        return [NSData dataWithBytesNoCopy:buffer_decrypt length:numBytesEncrypted];
    
    return nil;
}

- (NSData *)getSymmetricKeyBytes {
	OSStatus sanityCheck = noErr;
	NSData * symmetricKeyReturn = nil;
	
	if (self.symmetricKey == nil) {
		NSMutableDictionary * querySymmetricKey = [[NSMutableDictionary alloc] init];
		
		// Set the private key query dictionary.
		[querySymmetricKey setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass];
		[querySymmetricKey setObject:symmetricTag forKey:(__bridge id)kSecAttrApplicationTag];
		[querySymmetricKey setObject:[NSNumber numberWithUnsignedInt:CSSM_ALGID_AES] forKey:(__bridge id)kSecAttrKeyType];
		[querySymmetricKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnData];
		
		CFTypeRef inTypeRef = (__bridge CFTypeRef)symmetricKeyReturn;
        
		// Get the key bits.
		sanityCheck = SecItemCopyMatching((__bridge CFDictionaryRef)querySymmetricKey, &inTypeRef);
		if (sanityCheck == noErr && symmetricKeyReturn != nil) {
			self.symmetricKey = symmetricKeyReturn;
		} else {
			self.symmetricKey = nil;
		}
		
	} else {
		symmetricKeyReturn = self.symmetricKey;
	}
    
	return symmetricKeyReturn;
}

- (void)generateSymmetricKey {
	OSStatus sanityCheck = noErr;
	uint8_t * symmetricKey1 = NULL;
	
	// First delete current symmetric key.
	[self deleteSymmetricKey];
	
	// Container dictionary
	NSMutableDictionary *symmetricKeyAttr = [[NSMutableDictionary alloc] init];
	[symmetricKeyAttr setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass];
	[symmetricKeyAttr setObject:self.symmetricTag forKey:(__bridge id)kSecAttrApplicationTag];
	[symmetricKeyAttr setObject:[NSNumber numberWithUnsignedInt:CSSM_ALGID_AES] forKey:(__bridge id)kSecAttrKeyType];
	[symmetricKeyAttr setObject:[NSNumber numberWithUnsignedInt:(unsigned int)(kChosenCipherKeySize << 3)] forKey:(__bridge id)kSecAttrKeySizeInBits];
	[symmetricKeyAttr setObject:[NSNumber numberWithUnsignedInt:(unsigned int)(kChosenCipherKeySize << 3)]	forKey:(__bridge id)kSecAttrEffectiveKeySize];
	[symmetricKeyAttr setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecAttrCanEncrypt];
	[symmetricKeyAttr setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecAttrCanDecrypt];
	[symmetricKeyAttr setObject:(id)kCFBooleanFalse forKey:(__bridge id)kSecAttrCanDerive];
	[symmetricKeyAttr setObject:(id)kCFBooleanFalse forKey:(__bridge id)kSecAttrCanSign];
	[symmetricKeyAttr setObject:(id)kCFBooleanFalse forKey:(__bridge id)kSecAttrCanVerify];
	[symmetricKeyAttr setObject:(id)kCFBooleanFalse forKey:(__bridge id)kSecAttrCanWrap];
	[symmetricKeyAttr setObject:(id)kCFBooleanFalse forKey:(__bridge id)kSecAttrCanUnwrap];
	
	// Allocate some buffer space. I don't trust calloc.
	symmetricKey1 = malloc( kChosenCipherKeySize * sizeof(uint8_t) );
	
	LOGGING_FACILITY( symmetricKey1 != NULL, @"Problem allocating buffer space for symmetric key generation." );
	
	memset((void *)symmetricKey1, 0x0, kChosenCipherKeySize);
	
	sanityCheck = SecRandomCopyBytes(kSecRandomDefault, kChosenCipherKeySize, symmetricKey1);
	LOGGING_FACILITY1( sanityCheck == noErr, @"Problem generating the symmetric key, OSStatus == %d.", sanityCheck );
	
	self.symmetricKey = [[NSData alloc] initWithBytes:(const void *)symmetricKey1 length:kChosenCipherKeySize];
	
	// Add the wrapped key data to the container dictionary.
	[symmetricKeyAttr setObject:self.symmetricKey
                         forKey:(__bridge id)kSecValueData];
	
	// Add the symmetric key to the keychain.
	sanityCheck = SecItemAdd((__bridge CFDictionaryRef) symmetricKeyAttr, NULL);
	LOGGING_FACILITY1( sanityCheck == noErr || sanityCheck == errSecDuplicateItem, @"Problem storing the symmetric key in the keychain, OSStatus == %d.", sanityCheck );
	
    
    NSLog(@"bytes in hex: %@", [self.symmetricKey description]);
    
	if (symmetricKey1) free(symmetricKey1);
}

- (void)deleteSymmetricKey {
	OSStatus sanityCheck = noErr;
	
	NSMutableDictionary * querySymmetricKey = [[NSMutableDictionary alloc] init];
	
	// Set the symmetric key query dictionary.
	[querySymmetricKey setObject:(__bridge id)kSecClassKey forKey:(__bridge id)kSecClass];
	[querySymmetricKey setObject:symmetricTag forKey:(__bridge id)kSecAttrApplicationTag];
	[querySymmetricKey setObject:[NSNumber numberWithUnsignedInt:CSSM_ALGID_AES] forKey:(__bridge id)kSecAttrKeyType];
	
	// Delete the symmetric key.
	sanityCheck = SecItemDelete((__bridge CFDictionaryRef)querySymmetricKey);
	LOGGING_FACILITY1( sanityCheck == noErr || sanityCheck == errSecItemNotFound, @"Error removing symmetric key, OSStatus == %d.", sanityCheck );
	
	
	symmetricKeyRef = nil;
}




@end
